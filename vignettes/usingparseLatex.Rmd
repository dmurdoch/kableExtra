---
title: "Using parseLatex in kableExtra"
author: "Duncan Murdoch"
date: "2025-02-23"
output: 
  html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Using parseLatex in kableExtra}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra2)
library(parseLatex)
```

## Introduction

These are notes about how to modify the LaTeX related code in
`kableExtra` to use the `parseLatex` package.

But first, why would you want to do this?

The motivation for developing the `parseLatex` package was to
support editing LaTeX code, because getting the regular expressions
right for regexp-based editing is so hard.  Having the LaTeX syntax
tree represented in an R object makes some editing easier.

Is it worth the trouble to reimplement all the code?  That's not 
clear yet.  I think it will be easier to get things right in 
complicated situations, but will it be fast enough?  

In any case, I've put together these notes to help remind myself
of how to do the edits.  Whether I'll recommend incorporated the
edits into `kableExtra`, and whether Hao will accept my
recommendation remains to be seen.

There are a lot of table-specific functions in `parseLatex`.  See
https://dmurdoch.github.io/parseLatex/reference/index.html#tables for the list.


### Changes to `table_info`

Many `kableExtra` functions use `magic_mirror_latex` to 
extract a lot of information from
the `kable` output.  By convention, this is saved
in a list named `table_info`, and cached in the output in 
an attribute named `kable_meta`.

This branch makes a number of changes to `magic_mirror_latex` 
to do the extraction.  It
adds the following fields:

- `tabularPath`:  the path within `parsedInput` to the `tabular`
environment (or `tabularx`, `longtable`, etc.).  Thus `parsedInput[[tabularPath]]` should return the table.
- `tablePath`:  the path within `parsedInput` to the `table` environment,
if there is one.  Otherwise this is `NULL`.
- `dataRows`:  This is a vector that gives the translation between
the original data rows of the input and the `tableRow` values.  For example, if 5 header lines are added, then there will be no more `dataRows` values, but all will be increased by 5.  For consistency
with the old code, the original header row counts as a data row,
i.e. `kbl(mtcars[1:5, ])` would have 6 data rows, with the first
being the header, and the rest containing the `mtcars` data.

It drops these fields:

- `valign2`, `valign3`: versions of `valign` with different escaping.
- `begin_tabular`, `end_tabular`:  cached versions of the start 
and end of the table
- `align_vector` and `align_vector_origin`:  versions of `align`
used in computations

Currently the code using `parseLatex` uses similar arguments to the 
original `kableExtra` code, but in the internal functions do not 
keep parsing and deparsing, the main argument is a parsed LaTeX 
object corresponding to the kable input.  Some attributes of the kable
input are copied over to the parsed object, and the `kable_meta` attribute
is attached, holding the `table_info` list.

## Tasks

### Editing cell contents

The basic strategy is to get the parsed table, change a cell,
and put back the table.  For example:
```{r}
latex <- kbl(mtcars[1:3, 1:3], format = "latex")
parsed <- kable_to_parsed(latex)
table_info <- magic_mirror(parsed)
table <- with(table_info, parsed[[tabularPath]])
table
tableCell(table, 2, 4)
tableCell(table, 2, 4) <- "modified"
tableCell(table, 2, 4)
table
# put the table back into the full document
parsed[[table_info$tabularPath]] <- table
```

### Editing whole rows

The `parseLatex::row_to_vector()` function converts a row from the
table into a character vector.  If you need to edit multiple
entries, this may be convenient.  For example,
```{r}
table
row <- row_to_vector(tableRow(table, 2))
row
row[2:3] <- as.numeric(row[2:3]) + 1
tableRow(table, 2) <- vector_to_row(row)
table
```

### Editing alignment

Use `parseLatex::columnOptions()` to extract the alignment
spec, and the assignment version to modify it.  For example:
```{r}
table
columnOptions(table)
# You don't need to wrap in braces, but you could if you wanted.
columnOptions(table) <- "lrrr"
table
```

### Editing rules (lines) in the table

```{r}
table
# The rules come before corresponding line, and after the last one
rules(table)
rule(table, 2) <- NULL
rules(table)
table
```

## Forms of indexing

LaTeX documents are naturally hierarchical in structure, and
the `LaTeX2` and related classes in `parseLatex` mirror this structure
as lists of items in which the items can also be lists of items.

Two forms of indexing are used in `parseLatex`.  One form, usually
called an "index", is a scalar.  In simple cases it corresponds to
R's `x[[index]]`, i.e. it simply selects an item from the list `x`.
The other form is called a "path".  It is typically a vector, and
corresponds to `x[[path]]`, which is expanded by R to
`x[[path[1]]][[path[2]]] ... [[path[length(path)]]]`.

However, things are not always simple. For performance reasons,
`parseLatex` has some items (with tag `"ITEMLIST"`)
which correspond to logical groupings in LaTeX rather than syntactic
groupings.  For example, the `prepare_table()` function groups items
in a tabular environment into the items that appear before any rows,
then a group for each row in the table. The rows are also broken up
into the parts before the cells, and a separate list for each cell.

By convention, the `index` into a list containing itemlists ignores
them.  It will return the `index`th item from the list after all the 
itemlist items have been concatenated.

For example, a table might be
```
\begin{tabular}{ll}
1 & 2 \\
3 & 4 \\
\end{tabular}
```
Before adding itemlists by calling `prepare_table()`, this table will 
have 9 items:  `{ll}`, `1`, `&`, `2`, `\\`, `3`, `&`, `4`, and `\\` 
plus whitespace between them. Ignoring whitespace, the item at 
index 2 would be `1`.  

After `table <- prepare_table(...)` is
called, `table[[2]]` will refer to the itemlist containing the whole
first row `"1 & 2 \\"`.  Nevertheless, we would still say `1` is at
index location 2, and could use the `index_to_path()` function to 
find its path, which would be something like `c(2,2,1)`, i.e. the
first item in the second itemlist (first cell) in the second itemlist
(first row) in the table.

The `path_to_index()` function can convert back to an index if that
makes sense, but it doesn't always make sense.  In the example above,
the path `c(1,1,1)` would refer to the `ll` text in the column
options of the table.  That does not have an index in the table,
only the full block `{ll}` does, and it is index 1.

Some related concepts and functions:

- A `LaTeX2range` or "range" for short is an object that contains a path and a vector of
entries within the item given by the path.  `get_range()` can be
used to extract those items from the full object.
- `paths_to_ranges()` takes two paths, and constructs a list
of `LaTeX2range` objects that contain all the items from one path
to the next.
This is a slow process and should be avoided by setting up
the itemlists in advance to match the kind of subsetting that is
expected. 

